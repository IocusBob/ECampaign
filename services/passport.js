var passport = require("passport")
var keys = require('../config/keys')
const GoogleStrategy = require("passport-google-oauth20").Strategy
const mongoose = require('mongoose');

// Now we are fetching the user object/table out of mongoose and assigning it to User
const User = mongoose.model('users')

// when the done method is called inside the passport.use() (see **) callback function, the model instance that is fetched/created is passed
// into the first argument of passport.serializeUser((<thisIsThatUser, done)). the <done> argument is the callback
passport.serializeUser((user, done)=>{
    // user.id is NOT the googleId that we captured, it is the ID that is automatically generated by mongo/it is kinda like the PK 
    // This is the part of code that prepares and sends a cookie to the web browser
    done(null, user.id);
});


// in deserializeUser, this time we have the id from the cookie (as thats what we sent in the serializeUser done() callback) and we try to
// find a record that matches this user in our debugger, then deserializeUser the cookie with the done callback. null is again error handling/object
passport.deserializeUser((userId, done)=>{
    User.findById(userId).then((user)=>{
        done(null, user)
    })
});

// passport.use() - telling passport to be aware of a new strategy available
// new GoogleStrategy() - Creates a new google passport stratety instance for passport to use. Config goes into the contructor().
// the first object is basically security. Firstly we have the Id and secret for the API but also the callbackURL is the url that
// we are expecting to redirect to once we have logged in successfully. If an attacker was to intercept this login and redirect the
// user to their own website etc. this would not work, google will only redirect back to the callbackURL if it is the same as the 
// callbackURL which is setup inside the google developer console when we got the APIs.
passport.use(new GoogleStrategy({
    clientID: keys.googleClientID,
    clientSecret: keys.googleClientSecret,
    callbackURL: "/auth/google/callback",
    // The next line is for Heroku's proxy server, we need to tell google strategy that a proxy server will be there otherwise it
    // gets suspicious about proxy servers and reverts the url to http, when heroku is using https. Google will see this mismatch
    // and it will bugger up my APIs.
    proxy: true
    },
    // The accessToken is basically the thing that allows us to change something inside someones Google account (like their contacts for example).
    // We would need this accessToken when requesting changes
    async (accessToken, refreshToken, profile, done)=>{ // ** 
        const existingUser = await User.findOne({ googleId: profile.id })
            if (existingUser){
                return done(null, existingUser);
            }
            const newUser = await new User({googleId: profile.id}).save()
            done(null, newUser)
        }
    )
);

// ----------PASSPORT FLOW----------
// 1 User clicks login in their browser. Our server makes a get request to /auth/google  (an address specified in the Google developer console).
// 2 Passport forwards the request to Google using the client ID and client secret we set up to register our app.
// 3 Google will then ask the user if they grant permission to our app to access their profile. If they grant permission, Google will send a response back to the server at /auth/google/callback  (a URI specified in the Google developer console and which matches the redirect route in the passport set up). The URI will also contain a code.
// 4 Passport again handles this route, pulling the code out of the URI and sending a request back to Google with the same code.
// 5 Google then responds with details about this user.
// 6 At this point, the callback in the Google strategy set up fires, giving us the userâ€™s profile data.
// 7 We check if there is a user in the database with the Google ID we have just got back. If there is none, we create a new user using that Google ID. We call done to inform passport that we can resume authenticating.
// 8 Passport calls serializeUser , which takes the user just authenticated and determines that we want to store the MongoDB ID to identify the user in the session. This is passed to cookie session which encodes the ID and sends it to the browser in the response header.
// 9 Whenever the user makes a follow-up request, the browser sends the cookie back with the same encoded token. Cookie session extracts and decodes the cookie data, assigning it to the session property on the request object. The request flows down to passport, which looks up req.session  and takes the MongoDB ID out and uses it in the deserializeUser  function. The user is found in the database using this ID. Passport then attaches this user to the request object as req.user . 
// 10 Passport also attaches a logout function to the request object which expires the cookie whenever the user accesses the logout route.